<style>
  *, *:before, *:after {
    box-sizing: border-box;
  }

  body {
    background: black;
    color: white;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    margin: 0;
  }

  select, button {
    border: 3px solid white;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(12px);
    border-radius: 12px;
    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    color: white;
    padding: 12px;
    font-size: 18px;
    gap: 8px;
  }

  button img {
    height: 21px;
  }

  label {
    font-size: 18px;
  }

  .overlay {
    display: flex;
    position: absolute;
    gap: 16px;
    padding: 16px;
    width: 100%;
    z-index: 2;
  }

  .container {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    padding: 12px;
  }

  video {
    background-color: white;
    filter: invert(100%);
    width: 100%;
    height: 100%;
    transition: transform 200ms ease;
    object-fit: contain;
  }

  .spacer {
    width: 100%;
  }
</style>

<div class="overlay">
  <div class="select">
    <label for="videoSource"></label>
    <select id="videoSource"></select>
  </div>

  <button class="rotate-button">
    <img src="arrow-clockwise-fill.svg">
    Rotate
  </button>

  <div class="spacer"></div>
  
  <button class="save-button">
    <img src="download-simple-fill.svg">
    Download
  </button>
</div>

<div class="container">
  <video autoplay muted playsinline></video>
</div>

<script>
  const state = {
    rotation: 0
  }

  var rotateButton = document.querySelector(".rotate-button");
  const downloadButton = document.querySelector('.save-button')

  var videoElement = document.querySelector("video");
  var videoSelect = document.querySelector("select#videoSource");

  videoSelect.onchange = getStream;

  rotateButton.addEventListener("click", () => {
    const styles = []

    if (state.rotation >= 360) {
      state.rotation = 0
      styles.push("transition: none;")
    } else {
      state.rotation += 90
    }

    styles.push(`transform: rotate(${state.rotation}deg);`)
    videoElement.setAttribute("style", styles.join(""))
  })

  downloadButton.addEventListener("click", async () => {
    const videoSource = videoSelect.value;

    const constraints = {
      video: { deviceId: videoSource ? { exact: videoSource } : undefined },
    };

    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    if (!stream) return

    const { width, height } = stream.getVideoTracks()[0].getSettings();

    const canvas = document.createElement("canvas")
    const context = canvas.getContext("2d")

    canvas.width = width
    canvas.height = height
    
    context.drawImage(videoElement, 0, 0, width, height)

    const imageData = context.getImageData(0, 0, width, height)

    for (let index = 0; index < imageData.data.length; index += 4) {
      imageData.data[index] = 255 - imageData.data[index];
      imageData.data[index + 1] = 255 - imageData.data[index + 1];
      imageData.data[index + 2] = 255 - imageData.data[index + 2];
    }

    context.putImageData(imageData, 0, 0);

    const link = document.createElement("a");
    link.download = "filename.png";
    link.href = canvas.toDataURL()
    link.click();
  })

  getStream().then(getDevices).then(gotDevices);

  function getDevices() {
    return navigator.mediaDevices.enumerateDevices();
  }

  function gotDevices(deviceInfos) {
    window.deviceInfos = deviceInfos;
    
    for (const deviceInfo of deviceInfos) {
      const option = document.createElement("option");
      option.value = deviceInfo.deviceId;

      if (deviceInfo.kind === "videoinput") {
        option.text = deviceInfo.label || `Camera ${videoSelect.length + 1}`;
        videoSelect.appendChild(option);
      }
    }
  }

  function getStream() {
    if (window.stream) {
      window.stream.getTracks().forEach((track) => {
        track.stop();
      });
    }

    const videoSource = videoSelect.value;

    const constraints = {
      video: { deviceId: videoSource ? { exact: videoSource } : undefined },
    };

    return navigator.mediaDevices
      .getUserMedia(constraints)
      .then(gotStream)
      .catch(handleError);
  }

  function gotStream(stream) {
    window.stream = stream;

    videoSelect.selectedIndex = [...videoSelect.options].findIndex(
      (option) => option.text === stream.getVideoTracks()[0].label
    );
    videoElement.srcObject = stream;
  }

  function handleError(error) {
    console.error("Error: ", error);
  }
</script>
